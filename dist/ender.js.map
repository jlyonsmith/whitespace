{"version":3,"sources":["../src/Ender.js"],"names":["Ender","constructor","log","readEolInfo","Promise","resolve","reject","readable","args","process","stdin","createReadStream","encoding","info","numCR","numLF","numCRLF","numLines","on","err","writable","fileContents","i","length","c","numEndings","pipe","writeNewFile","newlineChars","PassThrough","stdout","createWriteStream","flags","newNumLines","write","end","run","argv","options","string","boolean","alias","version","help","existsSync","error","eolList","includes","join","msg","n"],"mappings":"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","file":"Ender.js","sourcesContent":["import parseArgs from 'minimist'\nimport fs from 'fs'\nimport concat from 'concat-stream'\nimport autoBind from 'auto-bind2'\nimport { fullVersion } from './version'\nimport stream from 'stream'\n\nexport class Ender {\n  constructor(log) {\n    autoBind(this)\n    this.log = log\n  }\n\n  async readEolInfo() {\n    return new Promise((resolve, reject) => {\n      const readable = (!this.args['input-file'] ? process.stdin :\n        fs.createReadStream(this.args['input-file'], { encoding: 'utf8' }))\n\n      // Read the entire file && determine all the different line endings\n      let info = {\n        numCR: 0,\n        numLF: 0,\n        numCRLF: 0,\n        numLines: 1\n      }\n\n      readable.on('error', (err) => {\n        reject(err)\n      })\n      let writable = concat((fileContents) => {\n        info.fileContents = fileContents\n        let i = 0\n        while (i < fileContents.length) {\n          const c = fileContents[i]\n\n          if (c == '\\r') {\n            if (i < fileContents.length - 1 && fileContents[i + 1] == '\\n') {\n              info.numCRLF += 1\n              i += 1\n            } else {\n              info.numCR += 1\n            }\n\n            info.numLines += 1\n          } else if (c == '\\n') {\n            info.numLF += 1\n            info.numLines += 1\n          }\n          i += 1\n        }\n\n        info.numEndings = (info.numCR > 0 ? 1 : 0) + (info.numLF > 0 ? 1 : 0) + (info.numCRLF > 0 ? 1 : 0)\n        resolve(info)\n      })\n      readable.pipe(writable)\n    })\n  }\n\n  async writeNewFile(info) {\n    return new Promise((resolve, reject) => {\n      const newlineChars = (this.args['new-eol'] === 'cr' ? '\\r' : this.args['new-eol'] === 'lf' ? '\\n' : '\\r\\n')\n\n      let writable = null\n\n      if (!this.args['output-file']) {\n        writable = new stream.PassThrough()\n        writable.pipe(process.stdout)\n      } else {\n        writable = fs.createWriteStream(this.args['output-file'], { flags: 'w', encoding: 'utf8' })\n      }\n\n      writable.on('finish', () => {\n        resolve()\n      })\n      writable.on('error', (err) => {\n        reject()\n      })\n\n      let newNumLines = 1\n      let i = 0\n      while (i < info.fileContents.length) {\n        const c = info.fileContents[i]\n\n        if (c === '\\r') {\n          if (i < info.fileContents.length - 1 && info.fileContents[i + 1] == '\\n') {\n            i += 1\n          }\n\n          newNumLines += 1\n          writable.write(newlineChars)\n        } else if (c === '\\n') {\n          newNumLines += 1\n          writable.write(newlineChars)\n        } else {\n          writable.write(c)\n        }\n\n        i += 1\n      }\n      info.newNumLines = newNumLines\n      writable.end()\n    })\n  }\n\n  async run(argv) {\n    const options = {\n      string: [ 'new-eol', 'output-file' ],\n      boolean: [ 'help', 'version' ],\n      alias: {\n        'o': 'output-file',\n        'n': 'new-eol'\n      }\n    }\n    let args = parseArgs(argv, options)\n\n    if (args.version) {\n      this.log.info(fullVersion)\n      return 0\n    }\n\n    if (args.help) {\n      this.log.info(`\nEnd of line normalizer.\n\nender [<options>] <file>\n\n<file>                    The input file. Defaults to STDIN.\n-o, --output-file <file>  The output file. Can be the same as the input file. Defaults to STDOUT.\n-n, --new-eol <ending>    The new EOL, either 'auto', 'cr', 'lf', 'crlf'.  'auto' will use the most\n                          commonly occurring ending in the input file. Default is to just report endings.\n--help                    Displays help\n--version                 Displays version\n`)\n      return 0\n    }\n\n    args['input-file'] = (args['_'].length > 0 ? args['_'][0] : null)\n    this.args = args\n\n    if (args['input-file'] && !fs.existsSync(args['input-file'])) {\n      this.log.error(`File '${args['input-file']}' does not exist`)\n      return -1\n    }\n\n    const eolList = ['cr', 'lf', 'crlf', 'auto']\n    if (args['new-eol'] && !eolList.includes(args['new-eol'])) {\n      this.log.error(`New EOL must be one of ${eolList.join(', ')}`)\n      return -1\n    }\n\n    let info = await this.readEolInfo()\n    let msg = `'${args['input-file'] || '<STDIN>'}', ` +\n      `${info.numEndings > 1 ? 'mixed' : info.numCR > 0 ? 'cr' : info.numLF > 0 ? 'lf' : 'crlf'}, ` +\n      `${info.numLines} lines`\n\n    if (args['new-eol']) {\n      if (args['new-eol'] === 'auto') {\n        // Find the most common line ending && make that the automatic line ending\n        this.args['new-eol'] = 'lf'\n        let n = info.numLF\n\n        if (info.numCRLF > n) {\n          args['new-eol'] = 'crlf'\n          n = info.numCRLF\n        }\n\n        if (info.numCR > n) {\n          args['new-eol'] = 'cr'\n        }\n      }\n\n      await this.writeNewFile(info)\n\n      msg += ` -> '${args['output-file'] || '<STDOUT>'}', ${this.args['new-eol']}, ${info.newNumLines} lines`\n    }\n\n    this.log.info(msg)\n    return 0\n  }\n}\n"]}