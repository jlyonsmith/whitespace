{"version":3,"sources":["../src/ender.js"],"names":["Ender","constructor","readLineEndingInfo","fileName","Promise","resolve","reject","readable","process","stdin","createReadStream","encoding","numCR","numLF","numCRLF","numLines","on","err","writeable","fileContents","i","length","c","numEndings","pipe","writeNewFile","info","newNumLines","mode","newLineEnding","newlineChars","stdout","createWriteStream","write","end","run","log","program","inputFilename","args","outputFilename","outputFile","existsSync","error","msg","report","n","version","arguments","name","description","option","parse","argv","ender","console"],"mappings":"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","file":"ender.js","sourcesContent":["import program from 'commander'\nimport fs from 'fs'\nimport concat from 'concat-stream'\n\nexport class Ender {\n  constructor() {\n  }\n\n  static async readLineEndingInfo(fileName) {\n    return new Promise((resolve, reject) => {\n      const readable = (fileName ? process.stdin : fs.createReadStream(fileName, { encoding: 'utf8' }))\n\n      // Read the entire file && determine all the different line endings\n      let numCR = 0\n      let numLF = 0\n      let numCRLF = 0\n      let numLines = 1\n\n      readable.on('error', (err) => {\n        reject(err)\n      })\n      let writeable = concat((fileContents) => {\n        let i = 0\n        while (i < fileContents.length) {\n          const c = fileContents[i]\n\n          if (c == '\\r') {\n            if (i < fileContents.length - 1 && fileContents[i + 1] == '\\n') {\n              numCRLF += 1\n              i += 1\n            } else {\n              numCR += 1\n            }\n\n            numLines += 1\n          } else if (c == '\\n') {\n            numLF += 1\n            numLines += 1\n          }\n          i += 1\n        }\n\n        numEndings = (numCR > 0 ? 1 : 0) + (numLF > 0 ? 1 : 0) + (numCRLF > 0 ? 1 : 0)\n\n        resolve({ numCR, numLF, numCRLF, numLines, numEndings, fileContents })\n      })\n      readable.pipe(writeable)\n    })\n  }\n\n  static async writeNewFile(fileName, info) {\n    return new Promise((resolve, reject) => {\n      let newNumLines = 1\n      let mode = program.mode\n\n      if ((info.newLineEnding == 'cr' && info.numCR + 1 == info.numLines) ||\n          (info.newLineEnding == 'lf' && info.numLF + 1 == info.numLines) ||\n          (info.newLineEnding == 'crlf' && info.numCRLF + 1 == info.numLines)) {\n        // We're not changing the line endings; nothing to do\n        return resolve()\n      }\n\n      const newlineChars = (info.newLineEnding == 'cr' ? '\\r' : mode == 'lf' ? '\\n' : '\\r\\n')\n      const writeable = (fileName ? process.stdout : fs.createWriteStream(fileName, 'w'))\n\n      writeable.on('finish', () => {\n        resolve()\n      })\n      writeable.on('error', (err) => {\n        reject()\n      })\n\n      let i = 0\n      while (i < info.fileContents.length) {\n        const c = info.fileContents[i]\n\n        if (c == '\\r') {\n          if (i < info.fileContents.length - 1 && info.fileContents[i + 1] == '\\n') {\n            i += 1\n          }\n\n          newNumLines += 1\n          writeable.write(newlineChars)\n        } else if (c == '\\n') {\n          newNumLines += 1\n          writeable.write(newlineChars)\n        } else {\n          writeable.write(c)\n        }\n\n        i += 1\n      }\n      writeable.end()\n      info.newNumLines = newNumLines\n    })\n  }\n\n  async run(log, program) {\n    const inputFilename = program.args.length > 0 ? program.args[0] : null\n    const outputFilename = program.outputFile\n\n    if (inputFilename && !fs.existsSync(inputFilename)) {\n      log.error(`File '${inputFilename}' does not exist`)\n      return -1\n    }\n\n    let info = await Ender.readLineEndingInfo(inputFilename)\n\n    msg = `\"${inputFilename}\", ${info.numEndings > 1 ? 'mixed' : info.numCR > 0 ? 'cr' : info.numLF > 0 ? 'lf' : 'crlf'}, ${info.numLines} lines`\n\n    if (program.report) {\n      log.info(msg)\n      return 0\n    }\n\n    if (program.mode == 'auto') {\n      // Find the most common line ending && make that the automatic line ending\n      info.newLineEnding = 'lf'\n      let n = info.numLF\n\n      if (numCRLF > n) {\n        info.newLineEnding = 'crlf'\n        n = numCRLF\n      }\n\n      if (numCR > n) {\n        info.newLineEnding = 'cr'\n      }\n    }\n\n    await Ender.writeNewFile(outputFilename, info)\n\n    msg += ` -> \"${outputFilename}\", ${info.newLineEnding}, ${info.newNumLines} lines`\n    log.info(msg)\n    return 0\n  }\n}\n\nprogram\n  .version('1.0.0')\n  .arguments('[file]')\n  .name('ender')\n  .description('Line ending fixer. Defaults to reading from stdin.')\n  .option('-o, --output-file <file>', 'The output file. Can be the same as the input file.' +\n    ' Defaults to stdout')\n  .option('-r, --report', 'Report on the status of the file and exit.')\n  .option('-m, --mode MODE', 'The convert mode, either auto, cr, lf, crlf. auto will use the most' +\n    ' commonly occurring ending.', /^(auto|lf|cr|crlf)$/, 'auto')\n\nprogram.parse(process.argv)\nconst ender = new Ender()\nender.run(console, program)\n"]}