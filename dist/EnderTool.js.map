{"version":3,"sources":["../src/EnderTool.js"],"names":["EnderTool","autobind","constructor","log","readEolInfo","Promise","resolve","reject","readable","args","process","stdin","fs","createReadStream","encoding","info","numCR","numLF","numCRLF","numLines","on","err","writable","fileContents","i","length","c","numEndings","pipe","writeNewFile","newlineChars","stream","PassThrough","stdout","createWriteStream","flags","newNumLines","write","end","run","argv","options","string","boolean","alias","o","n","version","fullVersion","help","existsSync","error","eolList","includes","join","msg"],"mappings":"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","sourcesContent":["import parseArgs from \"minimist\"\nimport fs from \"fs\"\nimport concat from \"concat-stream\"\nimport { fullVersion } from \"./version\"\nimport stream from \"stream\"\nimport autobind from \"autobind-decorator\"\n\n@autobind\nexport class EnderTool {\n  constructor(log) {\n    this.log = log\n  }\n\n  async readEolInfo() {\n    return new Promise((resolve, reject) => {\n      const readable = !this.args[\"input-file\"]\n        ? process.stdin\n        : fs.createReadStream(this.args[\"input-file\"], { encoding: \"utf8\" })\n\n      // Read the entire file && determine all the different line endings\n      let info = {\n        numCR: 0,\n        numLF: 0,\n        numCRLF: 0,\n        numLines: 1,\n      }\n\n      readable.on(\"error\", (err) => {\n        reject(err)\n      })\n      let writable = concat((fileContents) => {\n        info.fileContents = fileContents\n        let i = 0\n        while (i < fileContents.length) {\n          const c = fileContents[i]\n\n          if (c == \"\\r\") {\n            if (i < fileContents.length - 1 && fileContents[i + 1] == \"\\n\") {\n              info.numCRLF += 1\n              i += 1\n            } else {\n              info.numCR += 1\n            }\n\n            info.numLines += 1\n          } else if (c == \"\\n\") {\n            info.numLF += 1\n            info.numLines += 1\n          }\n          i += 1\n        }\n\n        info.numEndings =\n          (info.numCR > 0 ? 1 : 0) +\n          (info.numLF > 0 ? 1 : 0) +\n          (info.numCRLF > 0 ? 1 : 0)\n        resolve(info)\n      })\n      readable.pipe(writable)\n    })\n  }\n\n  async writeNewFile(info) {\n    return new Promise((resolve, reject) => {\n      const newlineChars =\n        this.args[\"new-eol\"] === \"cr\"\n          ? \"\\r\"\n          : this.args[\"new-eol\"] === \"lf\"\n          ? \"\\n\"\n          : \"\\r\\n\"\n\n      let writable = null\n\n      if (!this.args[\"output-file\"]) {\n        writable = new stream.PassThrough()\n        writable.pipe(process.stdout)\n      } else {\n        writable = fs.createWriteStream(this.args[\"output-file\"], {\n          flags: \"w\",\n          encoding: \"utf8\",\n        })\n      }\n\n      writable.on(\"finish\", () => {\n        resolve()\n      })\n      writable.on(\"error\", (err) => {\n        reject()\n      })\n\n      let newNumLines = 1\n      let i = 0\n      while (i < info.fileContents.length) {\n        const c = info.fileContents[i]\n\n        if (c === \"\\r\") {\n          if (\n            i < info.fileContents.length - 1 &&\n            info.fileContents[i + 1] == \"\\n\"\n          ) {\n            i += 1\n          }\n\n          newNumLines += 1\n          writable.write(newlineChars)\n        } else if (c === \"\\n\") {\n          newNumLines += 1\n          writable.write(newlineChars)\n        } else {\n          writable.write(c)\n        }\n\n        i += 1\n      }\n      info.newNumLines = newNumLines\n      writable.end()\n    })\n  }\n\n  async run(argv) {\n    const options = {\n      string: [\"new-eol\", \"output-file\"],\n      boolean: [\"help\", \"version\"],\n      alias: {\n        o: \"output-file\",\n        n: \"new-eol\",\n      },\n    }\n    let args = parseArgs(argv, options)\n\n    if (args.version) {\n      this.log.info(fullVersion)\n      return 0\n    }\n\n    if (args.help) {\n      this.log.info(`\nEnd of line normalizer.\n\nender [<options>] <file>\n\n<file>                    The input file. Defaults to STDIN.\n-o, --output-file <file>  The output file. Can be the same as the input file. Defaults to STDOUT.\n-n, --new-eol <ending>    The new EOL, either 'auto', 'cr', 'lf', 'crlf'.  'auto' will use the most\n                          commonly occurring ending in the input file. Default is to just report endings.\n--help                    Displays help\n--version                 Displays version\n`)\n      return 0\n    }\n\n    args[\"input-file\"] = args[\"_\"].length > 0 ? args[\"_\"][0] : null\n    this.args = args\n\n    if (args[\"input-file\"] && !fs.existsSync(args[\"input-file\"])) {\n      this.log.error(`File '${args[\"input-file\"]}' does not exist`)\n      return -1\n    }\n\n    const eolList = [\"cr\", \"lf\", \"crlf\", \"auto\"]\n    if (args[\"new-eol\"] && !eolList.includes(args[\"new-eol\"])) {\n      this.log.error(`New EOL must be one of ${eolList.join(\", \")}`)\n      return -1\n    }\n\n    let info = await this.readEolInfo()\n    let msg =\n      `'${args[\"input-file\"] || \"<STDIN>\"}', ` +\n      `${\n        info.numEndings > 1\n          ? \"mixed\"\n          : info.numCR > 0\n          ? \"cr\"\n          : info.numLF > 0\n          ? \"lf\"\n          : \"crlf\"\n      }, ` +\n      `${info.numLines} lines`\n\n    if (args[\"new-eol\"]) {\n      if (args[\"new-eol\"] === \"auto\") {\n        // Find the most common line ending && make that the automatic line ending\n        this.args[\"new-eol\"] = \"lf\"\n        let n = info.numLF\n\n        if (info.numCRLF > n) {\n          args[\"new-eol\"] = \"crlf\"\n          n = info.numCRLF\n        }\n\n        if (info.numCR > n) {\n          args[\"new-eol\"] = \"cr\"\n        }\n      }\n\n      await this.writeNewFile(info)\n\n      msg += ` -> '${args[\"output-file\"] || \"<STDOUT>\"}', ${\n        this.args[\"new-eol\"]\n      }, ${info.newNumLines} lines`\n    }\n\n    this.log.info(msg)\n    return 0\n  }\n}\n"],"file":"EnderTool.js"}